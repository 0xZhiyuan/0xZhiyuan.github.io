(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{359:function(e,t,a){"use strict";a.r(t);var n=a(25),s=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"polygon-zkevm-series-3-rom-induced-unprovable-transactions"}},[e._v("Polygon zkEVM Series 3: ROM-Induced Unprovable Transactions")]),e._v(" "),t("h2",{attrs:{id:"defination"}},[e._v("Defination")]),e._v(" "),t("p",[e._v("The ROM-induced unprovable transaction vulnerability in zk systems occurs when the ROM lacks checks for zkCounter or an execution path in the ROM contains unsolvable constraints.")]),e._v(" "),t("h2",{attrs:{id:"exploitation-scenario"}},[e._v("Exploitation Scenario")]),e._v(" "),t("p",[e._v("Since the state transition of such transaction is unprovable, the attacker can force the transaction to be finalized on L1 through a forced batch. Therefore, the L2 blockchain will be stuck.")]),e._v(" "),t("h2",{attrs:{id:"case-1-missing-mem-align-counter-check"}},[e._v("Case 1: Missing Mem-Align counter check")]),e._v(" "),t("p",[e._v("The Mem-Align counter checks are missing in the opcode CALLDATACOPY. Specifically, there is only a Mem-Align counter check at the start of the label "),t("code",[e._v("opCALLDATACOPY")]),e._v(" as shown below.")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("%MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2   :JMPN(outOfCountersMemalign)\n")])])]),t("p",[e._v("However, during the execution of the CALLDATACOPY opcode, the Mem-Align secondary state machine is used twice every time a 32-byte data is copied, but the the Mem-Align counter is not checked dynamically here.")]),e._v(" "),t("p",[e._v("In the CODECOPY opcode, the Mem-Align counter is checked as follows.")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("opCODECOPYloopInit:\n    ; checks zk-counters\n    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - E     :JMPN(outOfCountersMemalign)\n")])])]),t("p",[e._v("Unfortunately, this check is missing in the CALLDATACOPY opcode.")]),e._v(" "),t("p",[e._v("As a consequence, an attacker can construct a transaction that will use more than the maximum Mem-Align counter during execution. Next, the attacker can force this transaction to be finalized on L1 through a forced batch. However, since the Mem-Align counter consumed by this transaction exceeds the upper limit, its state transition cannot be proved by the prover. Therefore, the L2 blockchain will be stuck.")]),e._v(" "),t("h2",{attrs:{id:"case-2-incorrect-implementation-of-long-division"}},[e._v("Case 2: Incorrect implementation of long division")]),e._v(" "),t("p",[e._v("The modexp precompile contract is implemented in the Etrog update of Polygon zkEVM. The "),t("code",[e._v("/modexp/array_lib/array_div_long.zkasm")]),e._v(" file implements the long division used in this precompile contract. However, the logic of the long division implemented in this file is incorrect. The erroneous logic is located in the following code snippet. Specifically, this code does not work when the remainder is 0 (i.e., when inA is divisible by inB).")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("array_div_long_mul_quo_inB:\n                        :CALL(array_mul)\n\n        $ => D          :MLOAD(array_div_long_len_inB)\n        %MAX_CNT_BINARY - CNT_BINARY - 1                                        :JMPN(outOfCountersBinary)\n        %MAX_CNT_STEPS - STEP        - 8 - 3*%ARRAY_MAX_LEN - 3*D - 1           :JMPN(outOfCountersStep)\n\n        ; Check the remainder\n        $0{receiveLenRemainder()} => D\n\n        ; 1] The received length must be between 1 and %ARRAY_MAX_LEN\n        D - 1 => E              :JMPN(failAssert) ; If D = 0, then fail\n        %ARRAY_MAX_LEN - D      :JMPN(failAssert) ; If D > %ARRAY_MAX_LEN, then fail\n        ; From here, 1 <= D <= %ARRAY_MAX_LEN\n\n        ; 2] To avoid non-determinism, we must ensure that the remainder is trimmed\n        ; i.e., that its last chunk is not 0\n        ${receiveRemainderChunk(E)} => A\n        0 => B\n        0               :EQ\n        ; From here, the remainder is trimmed\n\n        ; 3] Finally, we must ensure that the remainder is lower than inB\n        $ => C           :MLOAD(array_div_long_len_inB)\n        C - 1 => RR\n        D - 1 => E\n\n        ; save the first non-zero chunk of rem\n        A               :MSTORE(array_compare_inB + E)\n        E - 1 => E      :JMPN(array_div_long_compare_inB2)\n")])])]),t("p",[e._v("Firstly, the following code ensures that the length of the remainder is greater than or equal to 1.")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("; Check the remainder\n$0{receiveLenRemainder()} => D\n\n; 1] The received length must be between 1 and %ARRAY_MAX_LEN\nD - 1 => E              :JMPN(failAssert) ; If D = 0, then fail\n%ARRAY_MAX_LEN - D      :JMPN(failAssert) ; If D > %ARRAY_MAX_LEN, then fail\n; From here, 1 <= D <= %ARRAY_MAX_LEN\n")])])]),t("p",[e._v("Secondly, the code below ensures that the last chunk of the remainder is not 0.")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" ; i.e., that its last chunk is not 0\n${receiveRemainderChunk(E)} => A\n0 => B\n0               :EQ\n")])])]),t("p",[e._v("When the remainder is 0, the above two conditions cannot be met simultaneously, therefore, the state transition of this transaction cannot be proven!")]),e._v(" "),t("h2",{attrs:{id:"case-3-incorrect-array-size-in-the-modexp-precompile"}},[e._v("Case 3: Incorrect array size in the modexp precompile")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("/modexp/array_lib/array_div_long.zkasm")]),e._v(" file implements the long division used in the modexp precompile contract. The following code is used to copy data of length "),t("code",[e._v("array_mul_len_out")]),e._v(" from "),t("code",[e._v("array_mul_out")]),e._v(" to "),t("code",[e._v("array_add_AGTB_inA")]),e._v(".")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("array_div_long_compare2:\n                        :CALL(array_compare)\n\n        %MAX_CNT_STEPS - STEP - 5 - 3*%ARRAY_MAX_LEN - 4*%ARRAY_MAX_LEN - 1        :JMPN(outOfCountersStep)\n\n        2               :MLOAD(array_compare_result)\n\n        D               :MSTORE(array_div_long_len_rem)\n\n        ; prepare output and remainder to be added\n        $ => C          :MLOAD(array_mul_len_out)\n        C - 1 => RR\n        D - 1 => E\n\narray_div_long_res_to_add:\n        $ => A          :MLOAD(array_mul_out + RR)\n        A               :MSTORE(array_add_AGTB_inA + RR)\n        RR - 1 => RR    :JMPN(array_div_long_rem_to_add, array_div_long_res_to_add)\n")])])]),t("p",[e._v("However, as shown in the following code, the maximum length of array "),t("code",[e._v("array_mul_out")]),e._v(" is "),t("code",[e._v("%ARRAY_MAX_LEN_DOUBLED")]),e._v(" and the maximum length of array "),t("code",[e._v("array_add_AGTB_inA")]),e._v(" is "),t("code",[e._v("%ARRAY_MAX_LEN")]),e._v(".")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("VAR GLOBAL array_mul_out[%ARRAY_MAX_LEN_DOUBLED]\n")])])]),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("VAR GLOBAL array_add_AGTB_inA[%ARRAY_MAX_LEN]\n")])])]),t("p",[e._v("Therefore, when the length of array "),t("code",[e._v("array_mul_out")]),e._v(" is greater than "),t("code",[e._v("%ARRAY_MAX_LEN")]),e._v(", the above code will cause overflow when copying data. The overflow issue will cause the following PIL constraints cannot be satisfied which can lead to an unprovable transaction.")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1               :MLOAD(array_compare_result)\n")])])]),t("h2",{attrs:{id:"case-4-missing-checks-in-changel2block-transaction"}},[e._v("Case 4: Missing checks in ChangeL2Block transaction")]),e._v(" "),t("p",[e._v("Polygon zkEVM introduced a new transaction type, ChangeL2Block, in the Etrog update, with the format as follows. The "),t("code",[e._v("indexL1InfoTree")]),e._v(" variable is used to specify the path for the SMT proof.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(";; ChangeL2BlockTx:\n;;   - fields: [type | deltaTimestamp | indexL1InfoTree ]\n;;   - bytes:  [  1  |       4        |        4        ]\n")])])]),t("p",[e._v("In the file "),t("code",[e._v("process-change-l2-block.zkasm")]),e._v(", the following code is used to verify the SMT proof. The path of the SMT proof is "),t("code",[e._v("indexL1InfoTree")]),e._v(", and the leaf value is "),t("code",[e._v("Keccak256(gerL1InfoTree||blockHashL1||timestamp)")]),e._v(".")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$                                                   :MLOAD(indexL1InfoTree), JMPZ(skipSetGERL1InfoTree)\n\n${getL1InfoGER(mem.indexL1InfoTree)} => A           :MSTORE(gerL1InfoTree)\n${getL1InfoBlockHash(mem.indexL1InfoTree)} => B     :MSTORE(blockHashL1InfoTree)\n${getL1InfoTimestamp(mem.indexL1InfoTree)} => C     :MSTORE(timestampL1InfoTree)\n                                                    :CALL(verifyMerkleProof)\n")])])]),t("p",[e._v("The SMT is maintained by the L1 contract "),t("code",[e._v("DepositContractBase.sol")]),e._v(". From the "),t("code",[e._v("getRoot")]),e._v(" function, we know that the path of the SMT proof is "),t("code",[e._v("depositCount")]),e._v(".")]),e._v(" "),t("div",{staticClass:"language-solidity extra-class"},[t("pre",{pre:!0,attrs:{class:"language-solidity"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("getRoot")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("view")]),e._v(" virtual "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("returns")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("bytes32")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),t("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("bytes32")]),e._v(" node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),t("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("uint256")]),e._v(" size "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" depositCount"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),t("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("bytes32")]),e._v(" currentZeroHashHeight "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n            "),t("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("uint256")]),e._v(" height "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n            height "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v(" _DEPOSIT_CONTRACT_TREE_DEPTH"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n            height"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),e._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("size "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">>")]),e._v(" height"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("==")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n                node "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("keccak256")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("abi"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("encodePacked")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("_branch"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("height"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("else")]),e._v("\n                node "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("keccak256")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("abi"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("encodePacked")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" currentZeroHashHeight"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n            currentZeroHashHeight "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("keccak256")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n                abi"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("encodePacked")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("currentZeroHashHeight"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" currentZeroHashHeight"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n            "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),t("p",[e._v("Therefore, if a malicious sequencer set the "),t("code",[e._v("indexL1InfoTree")]),e._v(" variable in the "),t("code",[e._v("ChangeL2Block")]),e._v(" transaction to a very large number (much larger than the depositCount), the state transition of this batch will be unprovable. This is because the leaf value of such path is zero but "),t("code",[e._v("Keccak256(gerL1InfoTree||blockHashL1||timestamp)")]),e._v(" cannot be zero!")]),e._v(" "),t("h2",{attrs:{id:"disclose-timeline"}},[e._v("Disclose Timeline")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Case 1")]),e._v(": Reported in "),t("span",{staticStyle:{color:"blue"}},[e._v("August 2023")]),e._v(" and confirmed as "),t("span",{staticStyle:{color:"red"}},[e._v("high severity")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("Case 2")]),e._v(": Reported in "),t("span",{staticStyle:{color:"blue"}},[e._v("February 2024")]),e._v(" and confirmed as "),t("span",{staticStyle:{color:"red"}},[e._v("medium severity")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("Case 3")]),e._v(": Reported in "),t("span",{staticStyle:{color:"blue"}},[e._v("February 2024")]),e._v(" and acknowledged as internally known.")]),e._v(" "),t("li",[t("strong",[e._v("Case 4")]),e._v(": Reported in "),t("span",{staticStyle:{color:"blue"}},[e._v("February 2024")]),e._v(" and confirmed as "),t("span",{staticStyle:{color:"red"}},[e._v("medium severity")]),e._v(".")])])])}),[],!1,null,null,null);t.default=s.exports}}]);