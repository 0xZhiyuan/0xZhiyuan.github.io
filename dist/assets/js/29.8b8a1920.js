(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{358:function(e,t,n){"use strict";n.r(t);var a=n(25),o=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"polygon-zkevm-series-1-dual-execution-path-vulnerabilities"}},[e._v("Polygon zkEVM Series 1: Dual Execution Path Vulnerabilities")]),e._v(" "),t("h2",{attrs:{id:"defination"}},[e._v("Defination")]),e._v(" "),t("p",[e._v("A dual execution path vulnerability is fundamentally a soundness vulnerability. In the context of a zkEVM written in zkasm, such a vulnerability arises when multiple execution paths can lead to the same final state but consume different zk-related resources (e.g., STEP counters).")]),e._v(" "),t("h2",{attrs:{id:"exploitation-scenario"}},[e._v("Exploitation Scenario")]),e._v(" "),t("p",[e._v("Hereâ€™s how an attacker can exploit a dual execution path vulnerability in zkEVM:")]),e._v(" "),t("ol",[t("li",[t("p",[t("strong",[e._v("Crafting an Ambiguous Transaction")]),e._v(":\nDesign a transaction such that its execution can follow two different execution traces to reach the same state.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Valid Proof Generation")]),e._v(":\nUnder one branch, generate a proof for the transaction, consuming related-fewer STEP counters and reach valid state transition.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Forgery Proof Generation")]),e._v(":\nUnder another branch, generate a proof for the transaction, consuming more STEP counters and causing an out-of-counter error.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Implications")]),e._v(":\nThe transactions are both provable and can be used to disrupt system integrity by proving a valid execution to trigger an error.\nThis opens the door to attacks such as double-spending.")])])]),e._v(" "),t("h2",{attrs:{id:"case-1-in-elliptic-curve-calculations"}},[e._v("Case 1 in Elliptic Curve Calculations")]),e._v(" "),t("p",[e._v("The following code snippet in the file "),t("code",[e._v("mulPointEc.zkasm")]),e._v(" is used for elliptic curve calculations:")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("mulPointEc:\n    RR      :MSTORE(mulPointEc_RR)\n    HASHPOS :MSTORE(mulPointEc_HASHPOS)\n\n    256 => RCX\n\n    ; HASHPOS used to mulPointEc_p3_no_infinity\n    0n => HASHPOS :MSTORE(mulPointEc_p3_x)\n\n    0n      :MSTORE(mulPointEc_p3_y)\n\n    $ => A  :MLOAD(mulPointEc_p1_x)\n    $ => B  :MLOAD(mulPointEc_p1_y)\n    $ => C  :MLOAD(mulPointEc_p2_x)\n    $ => D  :MLOAD(mulPointEc_p2_y)\n\n    ; check p1.x == p2.x\n    ${A == C}     :JMPZ(mulPointDiffInitalPoints)\n    C             :ASSERT\n\n    ; check p1.y == p2.y\n    D => A\n    $             :EQ,JMPC(mulPointSameInitalPoints)\n\n    ; p2 == -p1\n    1n            :MSTORE(mulPointEc_p12_empty),JMP(mulPointEc_loop)\n\nmulPointSameInitalPoints:\n    ; p2 == p1\n    0n                        :MSTORE(mulPointEc_p12_empty)\n    $ => A                    :MLOAD(mulPointEc_p1_x)\n    ${xDblPointEc(A,B)} => E  :MSTORE(mulPointEc_p12_x)\n    ${yDblPointEc(A,B)}       :ARITH_ECADD_SAME, MSTORE(mulPointEc_p12_y),JMP(mulPointEc_loop)\n\nmulPointDiffInitalPoints:\n    ; p2.x != p1.x ==> p2 != p1\n    0n                            :MSTORE(mulPointEc_p12_empty)\n    ${xAddPointEc(A,B,C,D)} => E  :MSTORE(mulPointEc_p12_x)\n    ${yAddPointEc(A,B,C,D)}       :ARITH_ECADD_DIFFERENT, MSTORE(mulPointEc_p12_y)\n")])])]),t("p",[e._v("The key point is the following line:")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("${A == C}     :JMPZ(mulPointDiffInitalPoints)\n")])])]),t("p",[e._v("It can be seen that the execution branch of the program is determined by a free variable.")]),e._v(" "),t("p",[e._v("In the next line, the following code performs a dual path check to ensure that this branch is executed if and only if "),t("code",[e._v("A == C")]),e._v(".")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("C             :ASSERT\n")])])]),t("p",[e._v("However, a similar dual path check is missing in the "),t("code",[e._v("mulPointDiffInitalPoints")]),e._v(" label.\nThis allows a malicious prover to manipulate the free variable "),t("code",[e._v("${A == C}")]),e._v(" to bypass normal execution flow, leading to non-deterministic execution.")]),e._v(" "),t("h3",{attrs:{id:"steps-to-reproduce"}},[e._v("Steps to Reproduce")]),e._v(" "),t("ol",[t("li",[e._v("Set p1 and p2 to the same elliptic curve point. This implies "),t("code",[e._v("A == C")]),e._v(" (i.e., p1.x == p2.x).")]),e._v(" "),t("li",[e._v("Intentionally set the free variable "),t("code",[e._v("${A == C}")]),e._v(" to 0.")]),e._v(" "),t("li",[e._v("Observe that the program jumps to the "),t("code",[e._v("mulPointDiffInitalPoints")]),e._v(" label instead of "),t("code",[e._v("mulPointSameInitalPoints")]),e._v(".")]),e._v(" "),t("li",[e._v("At "),t("code",[e._v("mulPointDiffInitalPoints")]),e._v(", a point addition is executed even though point doubling should have occurred.")])]),e._v(" "),t("h3",{attrs:{id:"feasibility-analysis"}},[e._v("Feasibility Analysis")]),e._v(" "),t("p",[e._v("We know that the following 4 equations are used to verify calculations related to elliptic curves.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("EQ1: s * x2 - s * x1 - y2 + y1 + (q0 * p) = 0   ;lambda - ADD\nEQ2: 2 * s * y1 - 3 * x1 * x1 + (q0 * p) = 0    ;lambda - DBL\nEQ3: s * s - x1 - x2 - x3 + (q1 * p) = 0        ;x3\nEQ4: s * x1 - s * x3 - y1 - y3 + (q2 * p) = 0   ;y3\n")])])]),t("p",[e._v("To be specific, when performing point addition, EQ1, EQ3, and EQ4 are enabled. In contrast, when performing point doubling, EQ2, EQ3, and EQ4 are enabled.")]),e._v(" "),t("p",[e._v("Here, we aim to verify whether the constraints for point addition can be satisfied when p1 and p2 are the same point. Since p1 and p2 are the same points, it means that "),t("code",[e._v("x1==x2")]),e._v(" and "),t("code",[e._v("y1==y2")]),e._v(". As a result, EQ1 can be simplified as "),t("code",[e._v("y1=y2")]),e._v(", and there is no constraint to the committed polynomial "),t("code",[e._v("s")]),e._v(".")]),e._v(" "),t("p",[e._v("Therefore, we can simply set s equal to "),t("code",[e._v("3x1^2/2y1")]),e._v(", and this will produce the same x3 and y3 as the point doubling calculation. Until now, a dual execution path has proven to be feasible.")]),e._v(" "),t("h2",{attrs:{id:"case-2-in-ecrecover-implementation"}},[e._v("Case 2 in Ecrecover Implementation")]),e._v(" "),t("p",[e._v("It is known that the formula of the elliptic curve used by Ethereum is "),t("code",[e._v("y^2 = x^3 + 7 mod p")]),e._v(". Moreover, the value "),t("code",[e._v("r")]),e._v(" in the transaction signature is the x-coordinate of the point P (the point P is dynamically generated when signing the transaction). In the file "),t("code",[e._v("ecrecover.zkasm")]),e._v(", the following code derives the y-coordinate of the point P from its x-coordinate.")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ecrecover_v_ok:\n        ;\n        ; y^2 = x^3 + 7\n        ;\n        ; A*B*A + 7 = calculate y from x\n        $ => A,B    :MLOAD(ecrecover_r),CALL(mulFpEc)\n\n        C => A\n        $ => B      :MLOAD(ecrecover_r),CALL(mulFpEc)\n\n        7 => A      :CALL(addFpEc)\n\n\n        C           :MSTORE(ecrecover_y2),CALL(sqrtFpEc)\n\n        ;; If has root y ** (p-1)/2 = 1, if -1 => no root, not valid signature\n\n        %FPEC_NON_SQRT => A\n        C => B\n        $ => E      :EQ,JMPNC(ecrecover_has_sqrt)\n\n        ; hasn't sqrt, now verify\n\n        $ => C      :MLOAD(ecrecover_y2),CALL(checkSqrtFpEc)\n        ; check must return on A register 1, because the root has no solution\n        1           :ASSERT,JMP(ecrecover_not_exists_sqrt_of_y)\n")])])]),t("p",[e._v("Note that an x-coordinate corresponds to two points on the elliptic curve, and the "),t("code",[e._v("v")]),e._v(" value in the transaction signature is used to determine which of these two points corresponds to the signer's public key.")]),e._v(" "),t("p",[e._v("As shown below, from the definition of the function "),t("code",[e._v("sqrtFpEc")]),e._v(", we know that both the y-coordinates of the two points satisfy the corresponding constraints.")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("sqrtFpEc:\n\n        C               :MSTORE(sqrtFpC_tmp)\n\n        ; [A] * [A] + 0 = [D] * 2 ** 256 + [E]\n\n        ; set C because if jmp to sqrtFpEc C must have return value (FPEC_NON_SQRT)\n        ${var _sqrtFpEc_sqrt = sqrtFpEc(C) } => A,C   :MSTORE(sqrtFpC_res)\n        %FPEC_NON_SQRT => B\n        $                                             :EQ,JMPC(sqrtFpEc_End)\n\n        A => B\n        0 => C\n\n        $${var _sqrtFpEc_sq = _sqrtFpEc_sqrt * _sqrtFpEc_sqrt }\n\n        ${_sqrtFpEc_sq >> 256} => D\n        ${_sqrtFpEc_sq} => E :ARITH\n\n        ;\n        ; with committed E,D\n        ; FpEc * [k] + C = D * 2 ** 256 + E\n        ;\n\n        $ => C          :MLOAD(sqrtFpC_tmp)\n        ${_sqrtFpEc_sq / const.FPEC} => B\n        %FPEC => A\n        E :ARITH\n\n        $ => C          :MLOAD(sqrtFpC_res),RETURN\n\nsqrtFpEc_End:\n        :RETURN\n")])])]),t("p",[e._v("Next, in the file "),t("code",[e._v("ecrecover.zkasm")]),e._v(", the following code compares whether the y-coordinate output by the function "),t("code",[e._v("sqrtFpEc")]),e._v(" matches the correct y-coordinate indicated by the "),t("code",[e._v("v")]),e._v(" value in the transaction signature. It is matched only when the "),t("code",[e._v("v")]),e._v(" value and the y-coordinate have the same parity. If they don't match, the inverse of the y-coordinate is used for the remaining calculations.")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ecrecover_has_sqrt:\n        ; (v == 1b) ecrecover_y_parity = 0x00\n        ; (v == 1c) ecrecover_y_parity = 0x01\n\n        ; C,B: y = sqrt(y^2)\n        ; check B isn't an alias (B must be in [0, FPEC-1])\n\n        %FPEC_MINUS_ONE => A\n        0           :LT         ; assert to validate that B (y) isn't n alias.\n\n        ; C,B: y = sqrtFpEc(y^2)\n\n        0x01n => A\n        $ => A      :AND\n        $ => B      :MLOAD(ecrecover_v_parity)\n\n        ; ecrevover_y xor ecrecover_y_parity => 0 same parity, 1 different parity\n        ; ecrecover_y2  v parity\n        ; parity (A)       (B)      A+B-1\n        ;      0            0        -1     same parity\n        ;      0            1         0     different parity\n        ;      1            0         0     different parity\n        ;      1            1         1     same parity\n\n        A + B - 1   :JMPNZ(ecrecover_v_y2_same_parity)\n\n        ; calculate neg(ecrecover_y) C = (A:FPEC) - (B:ecrecovery_y)\n\n        %FPEC => A\n        C => B\n        $ => C      :SUB\n")])])]),t("p",[e._v("The key point here is that the function "),t("code",[e._v("sqrtFpEc")]),e._v(" can output two valid y-coordinates, and if the y-coordinate is not consistent with the "),t("code",[e._v("v")]),e._v(" value, it is corrected by taking its inverse. This incorrect implementation leads to dual execution paths. In other words, the output of the "),t("code",[e._v("sqrtFpEc")]),e._v(" function (i.e. the y-coordinate) can be arbitrarily set by the prover, and the program will continue to run regardless of whether the y-coordinate is consistent with the "),t("code",[e._v("v")]),e._v(" value. That is to say, if the prover makes the "),t("code",[e._v("sqrtFpEc")]),e._v(" function output different y-coordinates, it will lead to different program execution paths. One path will directly jump to the "),t("code",[e._v("ecrecover_v_y2_same_parity")]),e._v(" label, while the other will first calculate the inverse of the y-coordinate. Although these two execution paths produce the same computational results, they consume different amounts of the STEP counter.")]),e._v(" "),t("h2",{attrs:{id:"case-3-in-modexp-precompile"}},[e._v("Case 3 in Modexp Precompile")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("/modexp/array_lib/array_div_long.zkasm")]),e._v(" file implements the long division used in the modexp precompile contract. However, there exists a dual execution path vulnerability in this file. This file uses the following two pieces of code to verify the correctness of long division.")]),e._v(" "),t("p",[e._v("First, the following code ensures that the remainder is smaller than the divisor.")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("array_div_long_compare2:\n                        :CALL(array_compare)\n\n        %MAX_CNT_STEPS - STEP - 5 - 3*%ARRAY_MAX_LEN - 4*%ARRAY_MAX_LEN - 1        :JMPN(outOfCountersStep)\n\n        2               :MLOAD(array_compare_result)\n")])])]),t("p",[e._v("Second, the following code ensures that the quotient multiplied by the divisor plus the remainder equals the dividend.")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("array_div_long_compare3:\n                        :CALL(array_compare)\n\n        %MAX_CNT_STEPS - STEP - 4      :JMPN(outOfCountersStep)\n\n        1               :MLOAD(array_compare_result)\n")])])]),t("p",[e._v("These two checks guarantee the correctness of long division.")]),e._v(" "),t("p",[e._v("However, an attacker can still provide malicious data. The key insight to launching the attack is that the provided malicious data consumes a large amount of zkCounter in the process of big integer multiplication, so "),t("strong",[e._v("an out of counter error occurs before the above two checks are performed")]),e._v(".")]),e._v(" "),t("p",[e._v("For example, an attacker can malicious set the register C to "),t("code",[e._v("%ARRAY_MAX_LEN")]),e._v(" in the following code.")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("array_div_long_prepare_mul_quo_inB:\n        $0{receiveLenQuotient()} => C\n\n        ; The received length must be between 1 and %ARRAY_MAX_LEN\n        C - 1 => RR             :JMPN(failAssert) ; If C = 0, then fail\n        %ARRAY_MAX_LEN - C      :JMPN(failAssert) ; If C > %ARRAY_MAX_LEN, then fail\n")])])]),t("p",[e._v("Therefore, in the following big integer multiplication logic, about 900 ARITH zkCounter is consumed which is much larger than the original.")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("array_mul_long:\n        %MAX_CNT_ARITH - CNT_ARITH - 1        :JMPN(outOfCountersArith)\n        %MAX_CNT_STEPS - STEP      - 9        :JMPN(outOfCountersStep)\n\n        C => A\n        D => B\n        0 => C,D\n        ${A*B} => E :ARITH\n        A => C\n        B => D\n        ; E holds C*D\n\n        %MAX_CNT_BINARY - CNT_BINARY                 - 4*E                :JMPN(outOfCountersBinary)\n        %MAX_CNT_ARITH - CNT_ARITH                   - E                  :JMPN(outOfCountersArith)\n        %MAX_CNT_STEPS - STEP        - 7 - 2*C - 2*D - 33*E - 2 - 3*C - 1 :JMPN(outOfCountersStep)\n")])])]),t("p",[e._v("An attacker can craft a transaction that triggers an out of counter error in the following check after adding an additional 900 ARITH zkCounter.")]),e._v(" "),t("div",{staticClass:"language-zkasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("%MAX_CNT_ARITH - CNT_ARITH                   - E                  :JMPN(outOfCountersArith)\n")])])]),t("p",[e._v("In conclusion, an attacker can craft a transaction that can both be proven valid and be proven to trigger an out-of-counter error.")]),e._v(" "),t("h2",{attrs:{id:"disclose-timeline"}},[e._v("Disclose Timeline")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Case 1")]),e._v(": Reported in "),t("span",{staticStyle:{color:"blue"}},[e._v("August 2023")]),e._v(" and confirmed as "),t("span",{staticStyle:{color:"red"}},[e._v("high severity")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("Case 2")]),e._v(": Reported in "),t("span",{staticStyle:{color:"blue"}},[e._v("August 2023")]),e._v(" and confirmed as "),t("span",{staticStyle:{color:"red"}},[e._v("medium severity")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("Case 3")]),e._v(": Reported in "),t("span",{staticStyle:{color:"blue"}},[e._v("February 2024")]),e._v(" and confirmed as "),t("span",{staticStyle:{color:"red"}},[e._v("high severity")]),e._v(".")])])])}),[],!1,null,null,null);t.default=o.exports}}]);